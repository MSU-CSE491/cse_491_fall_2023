{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"How-To Guides","text":"<p>Below are a set of guides for how to develop your own modules and joining them together into an executable (potentially with additional analysis and data collection.)</p> <ul> <li> <p>How to compile - Walks through how to compile via CMake.</p> </li> <li> <p>How to Build an Agent - A guide to designing your own type of autonomous agent.</p> </li> <li> <p>How to Build a World - A guide to designing you own world with custom interaction modes among agents and other environmental properties.</p> </li> <li> <p>How to Build an Interface - How to build an interface that allows a human user to control an agent.</p> </li> <li> <p>How to Assemble a <code>main()</code> function - A guide to selecting worlds, agents, and interfaces and turning them into a custom executable (including how to collect data about the resulting system.)</p> </li> <li> <p>How to build, run, and create unit tests - Walks through how to build and run existing unit tests, as well as create new unit test files. </p> </li> </ul>"},{"location":"HowToAssembleAMain/","title":"How to Assemble a Main","text":"<p>Once you have your Agents, World, and Interface picked out, it's easy to assemble them into an <code>main()</code> function that you can turn into a working executable.</p> <p>Create the appropriate .cpp file, and follow these steps:</p> <ol> <li>Include all of the modules that you will be using.  In the case of <code>simple_main.cpp</code> this looks like:</li> </ol> <pre><code>#include \"Agents/PacingAgent.hpp\"\n#include \"Interfaces/TrashInterface.hpp\"\n#include \"Worlds/MazeWorld.hpp\"\n</code></pre> <ol> <li>Inside your <code>main()</code> function, start by building your world.  It should look something like:</li> </ol> <pre><code>main() {\n  cse491::MazeWorld world;\n</code></pre> <p>Some world types may be able to take arguments to their constructors, but most probably won't.</p> <ol> <li>Add in your agents using the <code>AddAgent</code> member function, specifying the type of agent with a template argument and the agent's name as a regular argument.  <code>AddAgent</code> will return a reference to the new agent, so you can immediately modify it, such as by setting its position.</li> </ol> <pre><code>  world.AddAgent&lt;cse491::PacingAgent&gt;(\"Pacer 1\").SetPosition(3,1);\n  world.AddAgent&lt;cse491::PacingAgent&gt;(\"Pacer 2\").SetPosition(6,1);\n</code></pre> <p>Furthermore, AddAgent can take additional parameters to set properties BEFORE configuration is run. For example, if you want to set stats for strength and speed, you could do something like:</p> <pre><code>  world.AddAgent&lt;cse491::PacingAgent&gt;(\"Pacer 1\", \"strength\", 1.0, \"speed\", 5.5).SetPosition(3,1);\n  world.AddAgent&lt;cse491::PacingAgent&gt;(\"Pacer 2\", \"strength\", 8.6, \"speed\", 1.2).SetPosition(6,1);\n</code></pre> <p>This will allow you to change what you do in agent configuration based on the properties provided.</p> <ol> <li>Add in your interface as a type of agent.  For example:</li> </ol> <pre><code>  world.AddAgent&lt;cse491::TrashInterface&gt;(\"Interface\").SetProperty(\"char\", '@');\n</code></pre> <p>This will set up any \"player\" characters.</p> <ol> <li>Launch the run using <code>world.Run();</code>.</li> </ol>"},{"location":"HowToAssembleAMain/#what-if-i-want-to-collect-extra-data-for-analysis","title":"What if I want to collect extra data for analysis?","text":"<p>If you want to track the agents and the world during a run, you will skip step 5 above and instead manually run the agents and update the world, collecting data as you go.</p> <p>For example, in place of <code>world.Run();</code> you could have:</p> <pre><code>  while (!world.GetRunOver()) {\n    world.RunAgents();\n    world.UpdateWorld();\n    // Collect extra data about the world here!\n  }\n</code></pre> <p>You should have access to all of the basic data in the world; we may need to expand the API to provide access if you don't have everything you need.</p>"},{"location":"HowToBuildAWorld/","title":"How to Build A World","text":"<p>When building your own world, the first steps are boilerplate:</p> <ol> <li> <p>Include the WorldBase file If you're in the Worlds/ directory, do this with: <code>#include \"../core/WorldBase.hpp\"</code></p> </li> <li> <p>Open your namespace.  Everything else you do should be done in your team's namespace.</p> </li> <li> <p>Build your world class, making sure to derive it from <code>WorldBase</code>.  Something like <code>class MYWorld : public WorldBase {</code>, but of course use your world name instead of \"MYWorld\".</p> </li> </ol> <p>In the private (or protected, if you prefer) section of the class, you may create any member variables that your world might use.  Additionally, you need to set up some internal functionality.  Specifically:</p> <ol> <li> <p>Create a enumeration where you will list all of the action types available to an agent.  The first action should always be a \"do nothing\" action and explicitly set to zero.  For example: <code>enum ActionType { REMAIN_STILL=0, MOVE_UP, MOVE_DOWN, MOVE_LEFT, MOVE_RIGHT };</code></p> </li> <li> <p>Add a <code>ConfigAgent</code> function that provides a new agent with a list of the actions that it has available.  For example:</p> </li> </ol> <pre><code>    /// Provide the agent with movement actions.\n    void ConfigAgent(AgentBase &amp; agent) override {\n      agent.AddAction(\"up\", MOVE_UP);\n      agent.AddAction(\"down\", MOVE_DOWN);\n      agent.AddAction(\"left\", MOVE_LEFT);\n      agent.AddAction(\"right\", MOVE_RIGHT);\n    }\n</code></pre> <p>In the public section of the class, you need to build a few more functions:</p> <ol> <li>A default constructor (i.e., <code>MYWorld() { ... }</code>).  You should do any normal set up for this world, including the member variables that you created above.  You should also specify the type options and initialize the <code>main_grid</code> for this world.</li> <li>Specify the type options with the <code>AddCellType</code> function, which is defined in the base class.     <code>AddCellType(\"dirt\", \"Regular ground\", ' ');     AddCellType(\"tree\", \"A tall tree\", '^');     AddCellType(\"river\", \"Flowing water\", '~');</code></li> <li> <p>An easy way to initialize the <code>main_grid</code> is to use the <code>Read()</code> member function on <code>WorldGrid</code> to load the grid from a file.  For example: <code>main_grid.Read(\"../assets/grids/MYWorld.grid\", type_options);</code></p> </li> <li> <p>Add a destructor (i.e., <code>~MYWorld() { ... }</code>).  This function only needs to have a body if you need to clean up one of the member variables you added.</p> </li> <li> <p>Build <code>int DoAction(AgentBase &amp; agent, size_t action_id) override { ... }</code> for your new world.  This function will be run automatically whenever an agent takes an action, specifying both the agent and action involved.</p> </li> </ol> <p>Finally you need to build a main file that initializes this world, add any needed agents (either autonomous agents or interfaces), and run.</p>"},{"location":"HowToBuildAWorld/#member-variables-inherited-from-worldbase","title":"Member variables inherited from <code>WorldBase</code>","text":"<p><code>WorldBase</code> has a lot of boilerplate functionality though almost all of it can be replaced in a derived world.</p> <p>There are five member variables maintained in the world: - <code>WorldGrid main_grid</code> - the \"main\" world that is passed to agents by default.  You may maintain additional grids if you choose, and may decide which one of these is seen by an agent. - <code>type_options_t type_options</code> - a vector of <code>CellType</code> information, which specifies the name of each cell, its description, and an (optional) ASCII symbol associated with it.  The position in this vector it he ID of a cell type. - <code>item_set_t item_set</code> - a vector of pointers to all of the \"items\" in this world.  The world can define and use items however it likes, though they should be type <code>cse491::Entity</code>.  Like agents, items can have arbitrary properties. - <code>agent_set_t agent_set</code> - a vector of all agents currently active in the world. - <code>bool run_over</code> - a value that defaults to false, but if you change it to true the run will terminate at the end of the current iteration.</p>"},{"location":"HowToBuildAWorld/#working-with-properties","title":"Working with properties","text":"<p>Agents can have arbitrarily named properties; worlds can add properties to the agents, and modify the (<code>double</code>) value associated with that property at any time.</p> <p>To add a property, simply give it a value, such as <code>agent.SetProperty(\"property_name\", value)</code> where <code>value</code> is a floating point number (it will default to 0.0 if you don't include it.)  This might be a good way to add \"hit points\" or \"size\" to agents.  You can alter what happens to an agent based on these properties; if an agent's hit points reach zero, you might kill it off.</p> <p>You can always set properties to new values later, or use <code>agent.HasProperty(\"property_name\")</code> to test if an agent has a property or <code>agent.GetProperty(\"property_name\")</code> to read its value.</p> <p>If at any point you want to remove a property, you can do so with <code>agent.RemoveProperty(\"property_name\")</code>.  For example, you might have a property called \"invisible\" that you add to an agent when it vanishes, but you remove when it reappears.</p> <p>For properties that you want agents to always possess, it's probably a good idea to set them in the <code>ConfigAgent()</code> function.</p>"},{"location":"HowToBuildAWorld/#providing-limited-data-to-agents","title":"Providing limited data to agents","text":"<p>Some worlds will want to provide agents with limited data, perhaps only showing rooms that the agent is currently in or items/agents nearby. To do this, the world will be responsible for producing or maintaining the alternate data structures and those are the ones that should be passed to agents when they are called.</p> <p>The default version of the function <code>WorldBase::RunAgents()</code> will use the full information provided in the world, but this is a virtual function.  If you override it in your derived class, you simply need to step through all of the agents and run <code>SelectAction</code> on each with the revised arguments.  (Of course, after each action is selected, make sure to also run <code>DoAction</code> and <code>SetActionResult</code> for each, as per the base class.)</p>"},{"location":"HowToBuildAWorld/#managing-non-agent-activities-in-the-world","title":"Managing non-agent activities in the world","text":"<p>In some worlds, you may want events happening in the background, independent of agents.  For example, crops might grow, seasons might change, or weather might occur. To manage these non-agent events, you simply need to override <code>UpdateWorld()</code> in your derived class.  Every time each agent is run (in the <code>Run()</code> function) UpdateWorld() is then called.  If you need a different balance for <code>UpdateWorld()</code> (perhaps you need it to go after every agent) simply override the Run() function in your derived World class.</p>"},{"location":"HowToBuildAnAgent/","title":"How to Build an Autonomous Agent","text":"<p>When building your own agent, the first steps are boilerplate:</p> <ol> <li> <p>Include the AgentBase file If you're in the Agents/ directory, do this with: <code>#include \"../core/AgentBase.hpp\"</code></p> </li> <li> <p>Open your namespace.  Everything else you do should be done in your team's namespace.</p> </li> <li> <p>Build your agent class, making sure to derive it from <code>AgentBase</code>.  Something like <code>class MYAgent : public AgentBase {</code>, but of course use your agent name instead of \"MYAgent\".</p> </li> </ol> <p>In the private (or protected, if you prefer) section of the class, you may create any member variables that your agent might use.  Remember that you also have the option of using agent properties (see below) instead of private variables if you want the values to be accessible to other modules.</p> <p>In the public section, you should create:</p> <ol> <li> <p>A constructor and destructor, as needed for your implementation (agents are not required to have any specific code here.)</p> </li> <li> <p>An Initialize function that gets run after the agent has been configured by the world.  This will allow an agent to set itself up based on the actions that were provided by the world.  This function has the format <code>bool Initialize() override {...}</code> and should return <code>false</code> if it detected a problem during initialization (such as a required action name is not available).</p> </li> <li> <p>A <code>SelectAction</code> function that identifies the action that the organism will take. The format for <code>SelectionAction</code> is:</p> </li> </ol> <pre><code>    size_t SelectAction(const WorldGrid &amp; grid,\n                        const type_options_t &amp; type_options,\n                        const item_set_t &amp; item_set,\n                        const agent_set_t &amp; agent_set) override\n    {\n      // An agent should use their current state as well as the provided\n      // grid, type_options, item_set, and agent set to decide next action.\n    }\n</code></pre> <p>The arguments passed in to <code>SelectAction</code> will be the full set of possibilities by default (i.e., the full grid, all type options, all items, and all agents), but some worlds may choose to maintain more limited versions of these variables containing only what an organism currently knows about.  In such cases it would be these more limited version that would be passed in to the function.</p> <p>As part of their current state, agents have two relevant member variables inherited from their base class.  (1) A map of strings to action IDs called <code>action_map</code>, that indicates which value to return to take an action by a given name, and (2) an <code>int</code> called <code>action_result</code> that indicates the results of their last action.  Usually <code>action_result</code> will be 1 or 0 to indicate success or failure of that action.</p>"},{"location":"HowToBuildAnAgent/#agent-properties","title":"Agent Properties","text":"<p>While properties are typically added to agents from a World, they are technically allowed to add properties to themselves, typically in their own constructor.  These properties might be ones that affect the behavior of the agents, but should also be accessible from outside of the Agent class itself.</p> <p>For example, you might want to put <code>double facing = 1.0;</code> inside the private section if facing should only ever be used by this class.  Alternatively you can put <code>SetProperty(\"facing\", 1.0);</code> in the constructor if you want it accessible to the world.  Any other class would be able to run <code>agent.HasProperty(\"facing\")</code> to determine if the property exists in <code>agent</code>, or <code>agent.GetProperty(\"facing\")</code> to retrieve its value.</p>"},{"location":"HowToBuildAnInterface/","title":"How to Build an Interface","text":"<p>When building your own interface, the first steps are boilerplate:</p> <ol> <li> <p>Include the InterfaceBase file If you're in the Interfaces/ directory, do this with: <code>#include \"../core/InterfaceBase.hpp\"</code></p> </li> <li> <p>Open your namespace.  Everything else you do should be done in your team's namespace.</p> </li> <li> <p>Build your Interface class, making sure to derive it from <code>InterfaceBase</code>.  Something like <code>class MYInterface : public InterfaceBase {</code>, but of course use your Interface name instead of \"MYInterface\".</p> </li> </ol> <p>In the private (or protected, if you prefer) section of the class, you may create any member functions or variables that your interface might use.  I recommend a series of helper functions, such as a <code>DrawGrid</code> function to display the current state of the world.</p> <p>In the public section, you should create:</p> <ol> <li> <p>A constructor and destructor, as needed for your implementation.  Interfaces will likely need to do substantial setup in the constructor and teardown in the destructor.</p> </li> <li> <p>Add an Initialize function. This gets run after the interface has been configured by the world, thus you will have access to all of the available actions in order to map them to buttons or other inputs.  This function has the format <code>bool Initialize() override {...}</code> and should return <code>true</code> as long as everything initialized correctly (false otherwise).</p> </li> <li> <p>A <code>SelectAction</code> function that presents to the user the current state of the world and then reports back the next action for the user's agent should take. The format for <code>SelectionAction</code> is:</p> </li> </ol> <pre><code>    size_t SelectAction(const WorldGrid &amp; grid,\n                        const type_options_t &amp; type_options,\n                        const item_set_t &amp; item_set,\n                        const agent_set_t &amp; agent_set) override\n    {\n      // An interface should keep track of the user's actions and report them\n      // back.  If the system is not supposed to wait for the user (i.e., real\n      // time) then return a zero any time the user has not selected an action.\n    }\n</code></pre> <p>The arguments passed in to <code>SelectAction</code> will be the full set of possibilities by default (i.e., the full grid, all type options, all items, and all agents), but some worlds may choose to maintain more limited versions of these variables containing only what an organism currently knows about.  In such cases it would be these more limited version that would be passed in to the function.</p> <p>As part of their current state, agents have two relevant member variables inherited from their base class.  (1) A map of strings to action IDs called <code>action_map</code>, that indicates which value to return to take an action by a given name, and (2) an <code>int</code> called <code>action_result</code> that indicates the results of their last action.  Usually <code>action_result</code> will be 1 or 0 to indicate success or failure of that action.</p>"},{"location":"HowToCompile/","title":"How to Compile","text":"<p>First you'll need to clone the repo with submodules. </p> <p>If you haven't yet cloned the repo, run: </p> <pre><code>git clone https://github.com/MSU-CSE491/cse_491_fall_2023.git --recursive\n</code></pre> <p>If you have already cloned the repo, but you need to download the submodules, run the following inside the repo's directory:</p> <pre><code>git submodule init\ngit submodule update\n</code></pre> <p>Now jump to the section for your operating system.</p>"},{"location":"HowToCompile/#compiling-under-linux","title":"Compiling under Linux","text":"<p>If you're on a Linux machine, you first need to download some dependencies for SFML.  Specifically, you need:  - freetype - x11 - xrandr - udev - opengl - flac - ogg - vorbis - vorbisenc - vorbisfile - openal - pthread</p> <p>If you're on Ubuntu or other similar Debian distro, you can run the following: </p> <pre><code>sudo apt install libX-dev\n</code></pre> <p>For library X. </p> <p>Once you have all dependencies downloaded, navigate to the root of the repo and run the following to build: </p> <pre><code>mkdir build\ncd build\ncmake ..\ncmake --build .\n</code></pre> <p>All compiled executables should be in the <code>/build/executables/</code> directory. </p>"},{"location":"HowToCompile/#compiling-under-macos","title":"Compiling under MacOS","text":"<p>Mac shouldn't require any additional dependencies, so simply run the following, starting at the root of the repo:</p> <pre><code>mkdir build\ncd build\ncmake ..\ncmake --build .\n</code></pre> <p>All compiled executables should be in the <code>/build/executables/</code> directory. </p>"},{"location":"HowToCompile/#compiling-under-windows-with-mingw","title":"Compiling under Windows with MinGW","text":"<p>After you have the repo and submodules downloaded, we need to ensure you have MinGW and CMake. In a command line window, try running <code>g++</code> and <code>cmake</code>, if either give a \"command not found\" message, then we need to install them. </p> <p>MinGW gives us g++, and can be downloaded here: https://winlibs.com/</p> <p>CMake can be downloaded from here: https://cmake.org/download/</p> <p>Note: You'll likely need to add both MinGW's and CMake's <code>bin</code> folder to your path (I think CMake has a <code>bin</code> directory, otherwise add whatever directory contains the executable).  To add a directory to your path, follow these instructions: https://www.architectryan.com/2018/03/17/add-to-the-path-on-windows-10/ Note that you may run into issues if the directories you're adding have spaces in their paths (e.g., \"C:\\Program Files...\" was giving me issues). If you run into this, I'd recommend creating a new directory on your <code>C:\\</code> drive, like <code>C:\\bin\\</code> and then add CMake and MinGW as subdirectories there. </p> <p>Once you have CMake and MinGW working in your terminal (note you'll have to restart cmd/VSCode/whatever to get the path changes to take effect), run the following from the root of your repo:</p> <pre><code>mkdir build\ncd build\ncmake -G \"MinGW Makefiles\" ..\ncmake --build .\n</code></pre> <p>All compiled executables should be in the <code>/build/executables/</code> directory. </p> <p>Note that if you tried to build using CMake before, it likely tried to use MSVC as a compiler. If so, just wipe the build folder and start fresh. </p>"},{"location":"HowToCompile/#how-to-compile-in-debug-mode","title":"How to compile in debug mode","text":"<p>To compile in debug mode, simply add <code>-DCMAKE_BUILD_TYPE=Debug</code> to the first cmake command. </p> <p>This would normally look like: </p> <pre><code>cmake -DCMAKE_BUILD_TYPE=Debug ..\n</code></pre> <p>Unless you're on Windows, which would be:</p> <pre><code>cmake -DCMAKE_BUILD_TYPE=Debug -G \"MinGW Makefiles\" ..\n</code></pre> <p>You can then build like normal. </p> <p>Note that you can also replace <code>Debug</code> with <code>Release</code> to compile with optimizations. </p>"},{"location":"HowToTest/","title":"HowToTest","text":"<p>This guide will demonstrate how to create, build, and run tests.</p> <p>Note: that these instructions should work on Mac and Linux systems. Windows instructions should be similar, but please add any information about working with tests on Windows via a pull request! </p> <p>Note: this guide assumes you have Catch2 downloaded.  If you haven't yet downloaded the repo, simply add a <code>--recursive</code> to the end of your <code>git clone</code>.  If you have downloaded the rest of the repo, simply initialize and update the submodules: </p> <pre><code>git submodule init\ngit submodule update\n</code></pre>"},{"location":"HowToTest/#how-to-compile-tests","title":"How to compile tests","text":"<p>First, navigate to the <code>tests</code> directory. </p> <pre><code>cd tests\n</code></pre> <p>Create a build directory within <code>tests</code>, if it does not already exist.</p> <pre><code>mkdir build\n</code></pre> <p>Note that this will likely through an error/warning if the directory already exists. </p> <p>Navigate into the <code>build</code> directory. </p> <pre><code>cd build\n</code></pre> <p>Now we need to use CMake to compile. This is a two step process. First we tell CMake where to find the files, relative to our current directory. </p> <pre><code>cmake ..\n</code></pre> <p>If that completes without errors, we can now build the files in our current directory. </p> <pre><code>cmake --build .\n</code></pre> <p>That should compile the unit tests.  Note that this process will take a while the first time as it needs to compile Catch2. It should be much faster in subsequent builds. </p>"},{"location":"HowToTest/#running-tests","title":"Running tests","text":"<p>If you are on a Mac or Linux system and wish to run all the unit tests, simply run </p> <pre><code>./run_tests.sh\n</code></pre> <p>from within the <code>build</code> directory (not just in <code>tests</code>). </p> <p>If you wish to run a particular test (or are on Windows), simply navigate to the test within the build directory.  For example, if we want to run tests for <code>WorldGrid</code> (which is in core), we would navigate like so: </p> <pre><code>cd unit/core\n</code></pre> <p>Once we're in the correct directory, we simply run the executable.  On Unix systems that looks like: </p> <pre><code>./tests-unit-core-WorldGrid\n</code></pre> <p>On Windows it should be similar, though it may have a <code>.exe</code> extension.</p>"},{"location":"HowToTest/#adding-new-tests","title":"Adding new tests","text":"<p>To add tests for a new file, navigate to the corresponding folder in the <code>tests/unit</code> directory (not in <code>tests/build</code>.  For example, if we want to add a test for a new file in <code>core</code>, from the root of the repo we would navigate like so: </p> <pre><code>cd tests/unit/core\n</code></pre> <p>Once in the correct directory we need to add the actual source code of the test.  This should be done as a new <code>.cpp</code> file, which will typically have the same name as the header file in source (e.g., <code>WorldGrid.hpp</code> will have a new test file called <code>WorldGrid.cpp</code>). </p> <p>Once you've created that file, you can start with this skeleton code: </p> <pre><code>/**\n * This file is part of the Fall 2023, CSE 491 course project.\n * @brief &lt;TODO&gt;\n **/\n\n// Catch2 \n#define CATCH_CONFIG_MAIN\n#include &lt;catch2/catch_all.hpp&gt;\n\n// Class project\n// Place your includes here\n// e.g., #include \"core/Data.hpp\"\n\nTEST_CASE(\"NAME\", \"[tags]\"){\n}\n\n</code></pre> <p>Finally, once you have some tests coded up, you need to make one more change.  Simply add the name of that file (including the <code>.cpp</code>!) to <code>targets.txt</code>.  CMake uses this file to ensure we compile the appropriate files. </p>"},{"location":"GP%20Agents%20Group%207/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace cowboys yeeeeeeeehaaaaaaaaa <ul> <li>class GPAgent </li> </ul> </li> <li>namespace cse491 </li> </ul>"},{"location":"GP%20Agents%20Group%207/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir source <ul> <li>dir Group7_GP_Agent <ul> <li>file agent.hpp this will be our agent class can be created </li> </ul> </li> </ul> </li> </ul>"},{"location":"GP%20Agents%20Group%207/namespacecowboys/","title":"Namespace cowboys","text":"<p>Namespace List &gt; cowboys</p> <p>yeeeeeeeehaaaaaaaaa </p>"},{"location":"GP%20Agents%20Group%207/namespacecowboys/#classes","title":"Classes","text":"Type Name class GPAgent <p>The documentation for this class was generated from the following file <code>source/Group7_GP_Agent/agent.hpp</code></p>"},{"location":"GP%20Agents%20Group%207/classcowboys_1_1_g_p_agent/","title":"Class cowboys::GPAgent","text":"<p>ClassList &gt; cowboys &gt; GPAgent</p> <p>Inherits the following classes: AgentBase</p>"},{"location":"GP%20Agents%20Group%207/classcowboys_1_1_g_p_agent/#public-functions","title":"Public Functions","text":"Type Name GPAgent (size_t id, const std::string &amp; name)  bool Initialize () overrideThis agent needs a specific set of actions to function. size_t SelectAction (const cse491::WorldGrid &amp; grid, const cse491::type_options_t &amp; type_options, const cse491::item_set_t &amp; item_set, const cse491::agent_set_t &amp; agent_set) overrideChoose the action to take a step in the appropriate direction. ~GPAgent () override"},{"location":"GP%20Agents%20Group%207/classcowboys_1_1_g_p_agent/#protected-attributes","title":"Protected Attributes","text":"Type Name size_t movementIndex   = = 0 const std::vector&lt; std::string &gt; predefinedMovement   = = {\"down\", \"down\",\"down\",\"down\", \"right\", \"right\", \"up\", \"up\", \"up\",\"up\", \"right\", \"right\",  \"right\",  \"right\",  \"right\",  \"right\",  \"right\", \"right\", \"right\",  \"right\", \"right\", \"left\", \"left\", \"left\"}"},{"location":"GP%20Agents%20Group%207/classcowboys_1_1_g_p_agent/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"GP%20Agents%20Group%207/classcowboys_1_1_g_p_agent/#function-gpagent","title":"function GPAgent","text":"<pre><code>inline cowboys::GPAgent::GPAgent (\n    size_t id,\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"GP%20Agents%20Group%207/classcowboys_1_1_g_p_agent/#function-initialize","title":"function Initialize","text":"<p>This agent needs a specific set of actions to function. </p> <pre><code>inline bool cowboys::GPAgent::Initialize () override\n</code></pre> <p>Returns:</p> <p>Success. </p>"},{"location":"GP%20Agents%20Group%207/classcowboys_1_1_g_p_agent/#function-selectaction","title":"function SelectAction","text":"<pre><code>inline size_t cowboys::GPAgent::SelectAction (\n    const cse491::WorldGrid &amp; grid,\n    const cse491::type_options_t &amp; type_options,\n    const cse491::item_set_t &amp; item_set,\n    const cse491::agent_set_t &amp; agent_set\n) override\n</code></pre>"},{"location":"GP%20Agents%20Group%207/classcowboys_1_1_g_p_agent/#function-gpagent_1","title":"function ~GPAgent","text":"<pre><code>cowboys::GPAgent::~GPAgent () override\n</code></pre>"},{"location":"GP%20Agents%20Group%207/classcowboys_1_1_g_p_agent/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"GP%20Agents%20Group%207/classcowboys_1_1_g_p_agent/#variable-movementindex","title":"variable movementIndex","text":"<pre><code>size_t movementIndex;\n</code></pre>"},{"location":"GP%20Agents%20Group%207/classcowboys_1_1_g_p_agent/#variable-predefinedmovement","title":"variable predefinedMovement","text":"<pre><code>const std::vector&lt;std::string&gt; predefinedMovement;\n</code></pre> <p>The documentation for this class was generated from the following file <code>source/Group7_GP_Agent/agent.hpp</code></p>"},{"location":"GP%20Agents%20Group%207/namespacecse491/","title":"Namespace cse491","text":"<p>Namespace List &gt; cse491</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"GP%20Agents%20Group%207/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/","title":"Dir source","text":"<p>FileList &gt; source</p>"},{"location":"GP%20Agents%20Group%207/dir_b2f33c71d4aa5e7af42a1ca61ff5af1b/#directories","title":"Directories","text":"Type Name dir Group7_GP_Agent <p>The documentation for this class was generated from the following file <code>source/</code></p>"},{"location":"GP%20Agents%20Group%207/dir_2917a1bbf314837e5575b308b680803f/","title":"Dir source/Group7_GP_Agent","text":"<p>FileList &gt; Group7_GP_Agent</p>"},{"location":"GP%20Agents%20Group%207/dir_2917a1bbf314837e5575b308b680803f/#files","title":"Files","text":"Type Name file agent.hpp this will be our agent class can be created <p>The documentation for this class was generated from the following file <code>source/Group7_GP_Agent/</code></p>"},{"location":"GP%20Agents%20Group%207/agent_8hpp/","title":"File agent.hpp","text":"<p>FileList &gt; Group7_GP_Agent &gt; agent.hpp</p> <p>Go to the source code of this file</p> <p>this will be our agent class can be created More...</p> <ul> <li><code>#include &lt;cassert&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;random&gt;</code></li> <li><code>#include \"../core/AgentBase.hpp\"</code></li> </ul>"},{"location":"GP%20Agents%20Group%207/agent_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace cowboys yeeeeeeeehaaaaaaaaa"},{"location":"GP%20Agents%20Group%207/agent_8hpp/#classes","title":"Classes","text":"Type Name class GPAgent"},{"location":"GP%20Agents%20Group%207/agent_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Author:</p> <p>Aman Dhruva Thamminana (thammina@msu.edu) </p> <p>Version:</p> <p>0.0.1 [internal] </p> <p>Date:</p> <p>2023-09-25</p> <p>Copyright:</p> <p>Copyright (c) 2023 </p> <p>The documentation for this class was generated from the following file <code>source/Group7_GP_Agent/agent.hpp</code></p>"},{"location":"GP%20Agents%20Group%207/agent_8hpp_source/","title":"File agent.hpp","text":"<p>File List &gt; Group7_GP_Agent &gt; agent.hpp</p> <p>Go to the documentation of this file</p> <pre><code>\n\n#pragma once\n\n#include &lt;cassert&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;iostream&gt;\n\n#include &lt;random&gt;\n\n#include \"../core/AgentBase.hpp\"\n\nnamespace cowboys\n{\n\n\n    class GPAgent : public cse491::AgentBase\n    {\n    protected:\n        const std::vector&lt;std::string&gt; predefinedMovement = {\"down\", \"down\",\"down\",\"down\", \"right\", \"right\", \"up\", \"up\", \"up\",\"up\", \"right\", \"right\",  \"right\",  \"right\",  \"right\",  \"right\",  \"right\", \"right\", \"right\",  \"right\", \"right\", \"left\", \"left\", \"left\"};\n\n        size_t movementIndex = 0; // current move of the agent\n\n    public:\n        GPAgent(size_t id, const std::string &amp;name) : AgentBase(id, name) {\n            std::random_device rd;\n            std::mt19937 gen(rd());\n\n\n            std::uniform_int_distribution&lt;int&gt; dist(0, 3); // size of the random set to 3 as we only have 4 actions initally\n        }\n        ~GPAgent() override = default;\n\n        bool Initialize() override\n        {\n            return true;\n        }\n\n\n        size_t SelectAction(const cse491::WorldGrid &amp;grid,\n                            const cse491::type_options_t &amp;type_options,\n                            const cse491::item_set_t &amp;item_set,\n                            const cse491::agent_set_t &amp;agent_set) override\n        {\n            if (movementIndex &gt;= predefinedMovement.size()){\n                return action_map[\"right\"]; // do nothing if it is out of bound for defined movement\n            }\n\n            auto action = action_map[predefinedMovement[movementIndex++]];\n            return action;\n        }\n    };\n\n}\n\n</code></pre>"},{"location":"GP%20Agents%20Group%207/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace cowboys yeeeeeeeehaaaaaaaaa </li> <li>namespace cse491 </li> </ul>"},{"location":"GP%20Agents%20Group%207/classes/","title":"Class Index","text":""},{"location":"GP%20Agents%20Group%207/classes/#g","title":"g","text":"<ul> <li>GPAgent (cowboys)</li> </ul>"},{"location":"GP%20Agents%20Group%207/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class AgentBase <ul> <li>class cowboys::GPAgent </li> </ul> </li> </ul>"},{"location":"GP%20Agents%20Group%207/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"GP%20Agents%20Group%207/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"GP%20Agents%20Group%207/class_members/","title":"Class Members","text":""},{"location":"GP%20Agents%20Group%207/class_members/#g","title":"g","text":"<ul> <li>GPAgent (cowboys::GPAgent)</li> </ul>"},{"location":"GP%20Agents%20Group%207/class_members/#i","title":"i","text":"<ul> <li>Initialize (cowboys::GPAgent)</li> </ul>"},{"location":"GP%20Agents%20Group%207/class_members/#m","title":"m","text":"<ul> <li>movementIndex (cowboys::GPAgent)</li> </ul>"},{"location":"GP%20Agents%20Group%207/class_members/#p","title":"p","text":"<ul> <li>predefinedMovement (cowboys::GPAgent)</li> </ul>"},{"location":"GP%20Agents%20Group%207/class_members/#s","title":"s","text":"<ul> <li>SelectAction (cowboys::GPAgent)</li> </ul>"},{"location":"GP%20Agents%20Group%207/class_members/#_1","title":"~","text":"<ul> <li>~GPAgent (cowboys::GPAgent)</li> </ul>"},{"location":"GP%20Agents%20Group%207/class_member_functions/","title":"Class Member Functions","text":""},{"location":"GP%20Agents%20Group%207/class_member_functions/#g","title":"g","text":"<ul> <li>GPAgent (cowboys::GPAgent)</li> </ul>"},{"location":"GP%20Agents%20Group%207/class_member_functions/#i","title":"i","text":"<ul> <li>Initialize (cowboys::GPAgent)</li> </ul>"},{"location":"GP%20Agents%20Group%207/class_member_functions/#s","title":"s","text":"<ul> <li>SelectAction (cowboys::GPAgent)</li> </ul>"},{"location":"GP%20Agents%20Group%207/class_member_functions/#_1","title":"~","text":"<ul> <li>~GPAgent (cowboys::GPAgent)</li> </ul>"},{"location":"GP%20Agents%20Group%207/class_member_variables/","title":"Class Member Variables","text":""},{"location":"GP%20Agents%20Group%207/class_member_variables/#m","title":"m","text":"<ul> <li>movementIndex (cowboys::GPAgent)</li> </ul>"},{"location":"GP%20Agents%20Group%207/class_member_variables/#p","title":"p","text":"<ul> <li>predefinedMovement (cowboys::GPAgent)</li> </ul>"},{"location":"GP%20Agents%20Group%207/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"GP%20Agents%20Group%207/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"GP%20Agents%20Group%207/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"GP%20Agents%20Group%207/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"GP%20Agents%20Group%207/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"GP%20Agents%20Group%207/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"GP%20Agents%20Group%207/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"GP%20Agents%20Group%207/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"GP%20Agents%20Group%207/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"GP%20Agents%20Group%207/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"GP%20Agents%20Group%207/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}